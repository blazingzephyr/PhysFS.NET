using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Icculus.PhysFS.NET.SourceGeneration;

[Generator]
public class DefinitionsSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }
#endif

        var attributeDeclarations = context
            .SyntaxProvider
            .CreateSyntaxProvider(SyntaxProviderPredicate, (syntax, _) => syntax.Node)
            .Collect();

        var compilationAndClasses = context.CompilationProvider.Combine(attributeDeclarations);
        context.RegisterSourceOutput(compilationAndClasses, GenerateSourceCode);
        context.RegisterPostInitializationOutput(PostInitializationOutput);
    }

    private bool SyntaxProviderPredicate(SyntaxNode node, CancellationToken token)
    {
        if (node is not MethodDeclarationSyntax method) return false;
        foreach (var list in method.AttributeLists)
        {
            foreach (var attribute in list.Attributes)
            {
                if (GetAttributeName(attribute) == "PhysFsFunctionDefinition" ||
                    GetAttributeName(attribute) == nameof(PhysFsFunctionDefinitionAttribute))
                {
                    return true;
                }
            }
        }
        return false;
    }

    private string? GetAttributeName(AttributeSyntax attribute)
    {
        string? name = attribute.Name switch
        {
            SimpleNameSyntax sns => sns.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };

        return name;
    }

    private void GenerateSourceCode(SourceProductionContext context, (Compilation, ImmutableArray<SyntaxNode>) data)
    {
        var (compilation, syntax) = data;
        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine("// ------------------------------------------------------------------------------");
        sourceBuilder.AppendLine("// <auto-generated>");
        sourceBuilder.AppendLine("//     This code was generated by a tool.");
        sourceBuilder.AppendLine("//");
        sourceBuilder.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        sourceBuilder.AppendLine("//     the code is regenerated.");
        sourceBuilder.AppendLine("// </auto-generated>");
        sourceBuilder.AppendLine("// ------------------------------------------------------------------------------");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Runtime.InteropServices;");
        sourceBuilder.AppendLine();

        foreach (MethodDeclarationSyntax method in syntax)
        {
            string entryPoint = string.Empty;
            object[] argTypes = [];
            object? physfsType = null;

            var paramOptions = new (INamedTypeSymbol MarshallerType, bool ShouldBeFreed)[method.ParameterList.Parameters.Count];
            (INamedTypeSymbol? returnMarshallerType, bool returnShouldBeFreed) = (null, false);
            INamedTypeSymbol[] callConvs = [];

            bool throwsPhysfsExceptions = false;

            var model = compilation.GetSemanticModel(method.SyntaxTree);
            if (model.GetDeclaredSymbol(method) is not IMethodSymbol methodSymbol) continue;

            // Process the parameters
            string[] nativeNames = Array.ConvertAll(methodSymbol.Parameters.ToArray(), p => $"__{p.Name}_native");
            for (int i = 0; i < methodSymbol.Parameters.Length; i++)
            {
                IParameterSymbol param = methodSymbol.Parameters[i];
                var paramAttributeData = param.GetAttributes();

                foreach (var attribute in paramAttributeData)
                {
                    switch (attribute.AttributeClass?.Name)
                    {
                        case nameof(PhysFsMarshalUsingAttribute):
                            INamedTypeSymbol? marshallerType = null;
                            bool shouldBeFreed = false;

                            for (int j = 0; j < attribute.ConstructorArguments.Length; j++)
                            {
                                if (j == 0) marshallerType = (attribute.ConstructorArguments[j].Value as INamedTypeSymbol)!;
                                if (j == 1) shouldBeFreed = (bool)attribute.ConstructorArguments[j].Value!;
                            }

                            paramOptions[i] = (marshallerType!, shouldBeFreed);
                            break;
                    }
                }
            }

            // Method's attribute data.
            var attributeData = methodSymbol.GetAttributes();
            foreach (var attribute in attributeData)
            {
                switch (attribute.AttributeClass?.Name)
                {
                    case nameof(PhysFsFunctionDefinitionAttribute):
                        for (int i = 0; i < attribute.ConstructorArguments.Length; i++)
                        {
                            if (i == 0) entryPoint = (attribute.ConstructorArguments[i].Value as string)!;
                            if (i == 1)
                            {
                                var values = attribute.ConstructorArguments[i].Values.ToArray();
                                argTypes = Array.ConvertAll(values, i => i.Value)!;
                            }
                            if (i == 2) physfsType = attribute.ConstructorArguments[i].Value!;
                        }
                        break;
                    
                    case nameof(PhysFsCallConvAttribute):
                        for (int i = 0; i < attribute.ConstructorArguments.Length; i++)
                        {
                            TypedConstant[] constants = attribute.ConstructorArguments[i].Values.ToArray();
                            INamedTypeSymbol?[] values = Array.ConvertAll(constants, i => i.Value as INamedTypeSymbol);
                            if (i == 0 && callConvs.Length == 0) callConvs = values!;
                        }
                        break;

                    case nameof(ThrowsPhysFsExceptionAttribute):
                        throwsPhysfsExceptions = true;
                        break;
                }
            }

            // Return value's attribute data.
            attributeData = methodSymbol.GetReturnTypeAttributes();
            foreach (var attribute in attributeData)
            {
                switch (attribute.AttributeClass?.Name)
                {
                    case nameof(PhysFsMarshalUsingAttribute):
                        for (int j = 0; j < attribute.ConstructorArguments.Length; j++)
                        {
                            if (j == 0) returnMarshallerType = (attribute.ConstructorArguments[j].Value as INamedTypeSymbol)!;
                            if (j == 1) returnShouldBeFreed = (bool)attribute.ConstructorArguments[j].Value!;
                        }
                        break;
                }
            }

            if (method.Parent is TypeDeclarationSyntax type)
            {
                if (type.Parent is BaseNamespaceDeclarationSyntax containingNamespace)
                {
                    // Generates the containing namespace.
                    sourceBuilder.Append(containingNamespace.NamespaceKeyword);
                    sourceBuilder.Append(' ');
                    sourceBuilder.Append(containingNamespace.Name);
                    sourceBuilder.AppendLine();
                    sourceBuilder.AppendLine("{");
                }

                // Generates the 'unsafe' keyword if not added already.
                SyntaxTokenList modifiers = type.Modifiers;
                if (modifiers.IndexOf(SyntaxKind.UnsafeKeyword) < 0)
                {
                    SyntaxToken unsafeKeyword = SyntaxFactory.Token(SyntaxKind.UnsafeKeyword);
                    int index = modifiers.IndexOf(SyntaxKind.PartialKeyword);

                    if (index < 0)
                    {
                        modifiers = modifiers.Add(unsafeKeyword);
                    }
                    else
                    {
                        unsafeKeyword = unsafeKeyword.WithTrailingTrivia(SyntaxFactory.Space);
                        modifiers = modifiers.Insert(index, unsafeKeyword);
                    }
                }

                // Generates the containing type.
                {
                    sourceBuilder.Append('\t');
                    sourceBuilder.Append(modifiers);
                    sourceBuilder.Append(' ');
                    sourceBuilder.Append(type.Keyword);
                    sourceBuilder.Append(' ');
                    sourceBuilder.Append(type.Identifier);
                    sourceBuilder.AppendLine();
                    sourceBuilder.Append('\t');
                    sourceBuilder.AppendLine("{");
                }

                // Type's attribute data.
                model = compilation.GetSemanticModel(type.SyntaxTree);
                if (model.GetDeclaredSymbol(type) is not INamedTypeSymbol typeSymbol) continue;

                attributeData = typeSymbol.GetAttributes();
                foreach (var attribute in attributeData)
                {
                    switch (attribute.AttributeClass?.Name)
                    {
                        case nameof(PhysFsCallConvAttribute):
                            for (int i = 0; i < attribute.ConstructorArguments.Length; i++)
                            {
                                var constants = attribute.ConstructorArguments[i].Values.ToArray();
                                INamedTypeSymbol?[] values = Array.ConvertAll(constants, i => i.Value as INamedTypeSymbol);
                                if (i == 0 && callConvs.Length == 0) callConvs = values!;
                            }
                            break;
                    }
                }
            }

            // Boilerplate code for generating a physfs function import.
            void GenerateDllImport(string entryPoint, string name, object? returnType, string modifiers = "", string arguments = "")
            {
                // Generates the DllImportAttribute.
                {
                    sourceBuilder.Append("\t\t\t");
                    sourceBuilder.Append("[global::");
                    sourceBuilder.Append(typeof(System.Runtime.InteropServices.DllImportAttribute));
                    sourceBuilder.Append("(\"physfs.dll\", EntryPoint = \"");
                    sourceBuilder.Append(entryPoint); //
                    sourceBuilder.AppendLine("\", ExactSpelling = true)]");
                }

                // Generates the UnmanagedCallConvAttribute.
                if (callConvs.Length > 0)
                {
                    sourceBuilder.Append("\t\t\t");
                    sourceBuilder.Append("[global::");
                    // The type does not exist on .NET Standard 2.0
                    // But since the main project is .NET 6+, it works as intended
                    sourceBuilder.Append("System.Runtime.InteropServices.UnmanagedCallConvAttribute");
                    sourceBuilder.Append("(CallConvs = [");
                    sourceBuilder.Append(string.Join(", ", Array.ConvertAll(callConvs, i => $"typeof(global::{i})")));
                    sourceBuilder.AppendLine("])]");
                }

                // Generates the function.
                {
                    sourceBuilder.Append("\t\t\t");
                    sourceBuilder.Append("static extern ");
                    sourceBuilder.Append(returnType);
                    sourceBuilder.Append(" ");
                    sourceBuilder.Append(name);
                    sourceBuilder.Append("(");
                    sourceBuilder.Append(arguments);
                    sourceBuilder.AppendLine(");");
                }
            }

            // Generates the method comment.
            {
                sourceBuilder.Append("\t\t");
                sourceBuilder.AppendLine("/// <summary>");
                sourceBuilder.Append("\t\t");
                sourceBuilder.AppendLine("/// TBA");
                sourceBuilder.Append("\t\t");
                sourceBuilder.AppendLine("/// </summary>");
                sourceBuilder.Append("\t\t");
                sourceBuilder.AppendLine("/// <returns>TBA</returns>");
            }

            // Generates the GeneratedCodeAttribute.
            {
                sourceBuilder.Append("\t\t");
                sourceBuilder.Append("[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"");
                sourceBuilder.Append(typeof(DefinitionsSourceGenerator));
                sourceBuilder.AppendLine("\", \"1.0.0.0\")]");
            }

            // Generates the method declaration.
            {
                var stripped = Array.ConvertAll(method.ParameterList.Parameters.ToArray(), p => p.WithAttributeLists([]));
                sourceBuilder.Append("\t\t");
                sourceBuilder.Append(method.Modifiers);
                sourceBuilder.Append(' ');
                sourceBuilder.Append(method.ReturnType);
                sourceBuilder.Append(' ');
                sourceBuilder.Append(method.Identifier);
                sourceBuilder.Append('(');
                sourceBuilder.Append(string.Join<ParameterSyntax>(", ", stripped));
                sourceBuilder.Append(')');
                sourceBuilder.AppendLine();
            }

            // Body.
            sourceBuilder.Append("\t\t");
            sourceBuilder.AppendLine("{");

            // Generates the pre-operation log.
            {
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.AppendLine("DebugLog(\"TBA #1\");");
                sourceBuilder.AppendLine();
            }

            // Generatest the conversion methods.
            for (int i = 0; i < paramOptions.Length; i++)
            {
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.Append("// Marshal - Convert managed data (");
                sourceBuilder.Append(methodSymbol.Parameters[i].Name);
                sourceBuilder.AppendLine(") to native data.");

                sourceBuilder.Append("\t\t\t");
                sourceBuilder.Append("scoped global::");
                sourceBuilder.Append(paramOptions[i].MarshallerType);
                sourceBuilder.Append(".ManagedToUnmanagedIn ");
                sourceBuilder.Append(nativeNames[i]);
                sourceBuilder.AppendLine("__marshaller = new();");

                sourceBuilder.Append("\t\t\t");
                sourceBuilder.Append(nativeNames[i]);
                sourceBuilder.Append("__marshaller.FromManaged(");
                sourceBuilder.Append(methodSymbol.Parameters[i].Name);
                sourceBuilder.Append(", stackalloc byte[global::");
                sourceBuilder.Append(paramOptions[i].MarshallerType);
                sourceBuilder.AppendLine(".ManagedToUnmanagedIn.BufferSize]);");

                sourceBuilder.Append("\t\t\t");
                sourceBuilder.Append("global::");
                sourceBuilder.Append(argTypes[i]);
                sourceBuilder.Append(' ');
                sourceBuilder.Append(nativeNames[i]);
                sourceBuilder.Append(" = ");
                sourceBuilder.Append(nativeNames[i]);
                sourceBuilder.AppendLine("__marshaller.ToUnmanaged();");
                sourceBuilder.AppendLine();
            }

            // Generates the function call.
            if (physfsType is not null && physfsType.ToString() != "void")
            {
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.Append(physfsType);
                sourceBuilder.AppendLine(" __retVal_native;");
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.AppendLine("{");
                sourceBuilder.Append("\t\t\t\t");
                sourceBuilder.Append("__retVal_native = __PInvoke(");
                sourceBuilder.Append(string.Join(", ", nativeNames));
                sourceBuilder.AppendLine(");");
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.AppendLine("}");
                sourceBuilder.AppendLine();
            }
            else
            {
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.Append("__PInvoke(");
                sourceBuilder.Append(string.Join(", ", nativeNames));
                sourceBuilder.AppendLine(");");
                sourceBuilder.AppendLine();
            }

            // Free the marshalled parameters.
            for (int i = 0; i < paramOptions.Length; i++)
            {
                if (paramOptions[i].ShouldBeFreed)
                {
                    sourceBuilder.Append("\t\t\t");
                    sourceBuilder.Append(nativeNames[i]);
                    sourceBuilder.AppendLine("__marshaller.Free();");
                    sourceBuilder.AppendLine();
                }
            }

            // Generates the exception.
            if (throwsPhysfsExceptions)
            {
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.AppendLine("if (__retVal_native == 0)");
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.AppendLine("{");

                sourceBuilder.Append("\t\t\t\t");
                sourceBuilder.Append("global::");
                sourceBuilder.Append(typeof(PhysFsErrorCode));
                sourceBuilder.AppendLine(" errorCode = PHYSFS_getLastErrorCode();");

                sourceBuilder.Append("\t\t\t\t");
                sourceBuilder.AppendLine("byte* error = PHYSFS_getErrorByCode(errorCode);");

                sourceBuilder.Append("\t\t\t\t");
                sourceBuilder.Append("string? errorText = ");
                sourceBuilder.Append("global::System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller.ConvertToManaged");
                sourceBuilder.AppendLine("(error);");
                
                sourceBuilder.Append("\t\t\t\t");
                sourceBuilder.Append("throw global::");
                sourceBuilder.Append(typeof(PhysFsExceptionUtility));
                sourceBuilder.Append('.');
                sourceBuilder.Append(nameof(PhysFsExceptionUtility.GetExceptionForPhysFsErr));
                sourceBuilder.AppendLine("(errorCode, errorText);");

                sourceBuilder.Append("\t\t\t");
                sourceBuilder.AppendLine("}");
                sourceBuilder.AppendLine();
            }

            // Generates successful operation message.
            {
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.AppendLine("DebugLog(\"TBA #2\");");
                sourceBuilder.AppendLine();
            }

            // Generates the return statement.
            if (methodSymbol.ReturnType.SpecialType != SpecialType.System_Void)
            {
                if (returnMarshallerType is not null)
                {
                    sourceBuilder.Append("\t\t\t");
                    sourceBuilder.AppendLine("// Unmarshal - Convert native data to managed data.");

                    sourceBuilder.Append("\t\t\t");
                    sourceBuilder.Append(method.ReturnType);
                    sourceBuilder.Append(" __retVal = global::");
                    sourceBuilder.Append(returnMarshallerType);
                    sourceBuilder.AppendLine(".ConvertToManaged(__retVal_native);");

                    sourceBuilder.Append("\t\t\t");
                    sourceBuilder.AppendLine("return __retVal;");
                    sourceBuilder.AppendLine();
                }
                else
                {
                    sourceBuilder.Append("\t\t\t");
                    sourceBuilder.AppendLine("return __retVal_native;");
                    sourceBuilder.AppendLine();
                }
            }

            // Starts building P/Invoke.
            sourceBuilder.Append("\t\t\t");
            sourceBuilder.AppendLine("// Local P/Invoke");

            // Generates P/Invoke code.
            {
                StringBuilder nativeArgs = new StringBuilder();
                for (int i = 0; i < argTypes.Length; i++)
                {
                    if (i > 0)
                        nativeArgs.Append(", ");

                    nativeArgs.Append("global::");
                    nativeArgs.Append(argTypes[i]);
                    nativeArgs.Append(' ');
                    nativeArgs.Append("__");
                    nativeArgs.Append(i < methodSymbol.Parameters.Length ? methodSymbol.Parameters[i].Name : $"arg{i}");
                    nativeArgs.Append("_native");
                }

                GenerateDllImport(entryPoint, "__PInvoke", physfsType, "unsafe ", nativeArgs.ToString());
                sourceBuilder.AppendLine();
            }

            // Starts building debug message.
            sourceBuilder.Append("\t\t\t");
            sourceBuilder.AppendLine("// Debug message");

            // Generates the ConditionalAttribute.
            {
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.Append("[global::");
                sourceBuilder.Append(typeof(System.Diagnostics.ConditionalAttribute));
                sourceBuilder.AppendLine("(\"DEBUG\")]");
            }

            // Generates debug message code.
            {
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.AppendLine("static void DebugLog(string message)");
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.AppendLine("{");
                sourceBuilder.Append("\t\t\t\t");
                sourceBuilder.AppendLine("global::System.Console.WriteLine(message);");
                sourceBuilder.Append("\t\t\t");
                sourceBuilder.AppendLine("}");
            }

            // Generates the physfs error-related imports.
            if (throwsPhysfsExceptions)
            {
                sourceBuilder.AppendLine();
                GenerateDllImport("PHYSFS_getLastErrorCode", "PHYSFS_getLastErrorCode", typeof(PhysFsErrorCode));
                sourceBuilder.AppendLine();
                GenerateDllImport("PHYSFS_getErrorByCode",
                                  "PHYSFS_getErrorByCode",
                                  typeof(byte*),
                                  "unsafe ",
                                  $"global::{typeof(PhysFsErrorCode)} code");
            }

            // Close the paranthesis.
            {
                sourceBuilder.Append("\t\t");
                sourceBuilder.AppendLine("}");
                sourceBuilder.AppendLine("\t}");
                sourceBuilder.AppendLine("}");
            }
        }

        var sourceText = sourceBuilder.ToString();
        context.AddSource($"physfs.g.cs", sourceText);
    }

    private void PostInitializationOutput(IncrementalGeneratorPostInitializationContext context)
    {
        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine("// Generator initialized");
        sourceBuilder.Append("// ");
        sourceBuilder.Append(DateTime.Now);

        var sourceText = sourceBuilder.ToString();
        context.AddSource("debug.init.cs", sourceText);
    }

}
